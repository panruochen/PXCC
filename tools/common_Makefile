###############################################################################
#
# A YES MAKEFILE TEMPLATE
#
# The purpose of implementing this script is help quickly deploy source code
# tree during initial phase of development. It is designed to manage one whole
# project from within one single makefile and to be easily adapted to
# different directory hierarchy by simply setting user configurable variables.
# This script is expected to be used with gcc toolchains on bash-compatible
# shell.
#
# Author: Pan Ruochen <ijkxyz@msn.com>
# Date:   2012/10/10
#
#
# You can get the latest version from here:
# https://github.com/panruochen/dragoneye
#
###############################################################################

#-----------------------------------------------------------------------------------------------------#
# User Defined Variables
#
# ====================================================================================================
# GNU_TOOLCHAIN_PREFIX:   The perfix of gnu toolchain.
# ====================================================================================================
# CFLAGS:         Compiler flags.
# INCS:           Header files include paths.
# SRCS:           Sources. The entriess ending with a trailing / are taken as directories, the others
#                 are taken as files. The files with specified extension names in those directories will
#                 be automatically involved in compilation.
# COMPILE[X]:     User defined command to generate targets for the prerequisites
#                 whith the specified extension name X (i.e, X could be c, cpp, etc).
#
# EXCLUDE_FILES:  The files that are not included during compilation.
# OBJ_DIR:        The directory where object files are output.
# LDFLAGS:        Linker flags.
# STRIP_UNUSED:   Remove all unreferenced functions and data on linking.
# ====================================================================================================
# TARGET:         The target name with path.
# TARGET_DEPENDS: The dependencies of the target.
# ====================================================================================================
# SRC_EXTS:       The extension names of source files.
# OBJ_EXT:        The extension name of object files.
# DEP_EXT:        The extension name of dependency files.
# ====================================================================================================
# INDEPENDENT_OF_MAKEFILE_LIST:    This project is independent of the makefile list. That is any
#                                  change of the makefile list will not cause remaking of the project.
# VERBOSE:                         Display verbose commands instead of short commands during
#                                  the make process.
#-----------------------------------------------------------------------------------------------------#

#--------------------------------------------------------#
# Make sure the default target "all" is the first target
#--------------------------------------------------------#
ifndef __ycm_include_once

__ycm_include_once := 1

.PHONY: all clean distclean

#**************************************************************
# Basical functions
#**************************************************************
eq = $(if $(subst $1,,$2),,1)

do_ifeq  = $(if $(subst $1,,$2),,$3)
do_ifneq = $(if $(subst $1,,$2),$3)

define more_nl
=================================================================


$1
endef

#exec = $(info $(call more_nl,$1))$(eval $1)
exec = $(eval $1)

info2 =$(info $(X)$1 = $($(X)$1))

check_vars = $(foreach i,$1,$(if $($i),$(error Variable $i has been used! $($i))))
clean_vars = $(foreach i,$1,$(eval $i:=))

in_list = $(strip $(foreach i,$2,$(if $(subst $(strip $1),,$i),,$1)))#<>

unique = $(call check_vars,__ymt_uniq_v)\
$(strip $(foreach i,$1,$(if $(call in_list,$i,$(__ymt_uniq_v)),,$(eval __ymt_uniq_v+=$i)))$(__ymt_uniq_v))\
$(call clean_vars,__ymt_uniq_v)

std_path = $(strip $(subst /./,/, \
  $(eval __ymt_std_path_v := $(subst ././,./,$(subst //,/,$(subst \\,/,$1)))) \
   $(if $(subst $(__ymt_std_path_v),,$1),$(call std_path,$(__ymt_std_path_v)),$1)))

get_path_list =$(call check_vars,__ymt_v1)
get_path_list+=$(eval __ymt_v1 := $(call std_path,$1))$(call unique,$(call in_list, ./, $(__ymt_v1)) $(patsubst ./%,%,$(__ymt_v1)))
get_path_list+=$(call clean_vars,__ymt_v1)

#--------------------------------------------------------------#
# Add a trailing LF character to the texts                     #
#  $1 -- The texts                                             #
#--------------------------------------------------------------#
define nl
$1

endef

DEFAULT_SRC_EXTS :=  c cpp cc cxx S s
system_vars := CLAGS SRCS INCS DEFINES EXTRA_CFLAGS TARGET \
  EXCLUDE_FILES LIBS OBJ_DIR TARGET_DEPENDS EXTERNAL_DEPENDS VERBOSE SRC_EXTS
CLEAN_VARS = $(call clean_vars, $(system_vars))

build_target = $(eval TARGET_TYPE := $1)$(eval X := $(TARGET)-)$(eval ymt_all_targets += $(X)) \
  $(foreach i,$(system_vars),$(eval $(X)$i := $($i))) \
  $(call exec,include $(firstword $(MAKEFILE_LIST)))

BUILD_EXECUTABLE     = $(call build_target,EXE)
BUILD_SHARED_OBJECT  = $(call build_target,SO)
BUILD_STATIC_LIBRARY = $(call build_target,LIB)
BUILD_RAW_BINARY     = $(call build_target,BIN)

all: build-all
clean: clean-all
distclean: distclean-all
print-%:
	@echo $* = $($*)

.DEFAULT_GOAL = all

.PHONY: clean-all build-all distclean-all

#**************************************************************
#  include external configurations
#**************************************************************
$(foreach i,$(PROJECT_CONFIGS),$(eval include $i))

build-all: $(foreach i,$(ymt_all_targets),$($(i)TARGET))
clean-all: $(foreach i,$(ymt_all_targets),clean-$($(i)TARGET))
distclean-all: $(foreach i,$(ymt_all_targets),distclean-$($(i)TARGET))

endif #__ycm_include_once

#########################################################################################################################################################
# Project specified parts
#

ifndef $(X)quiet_cmd_cc

$(if $(strip $(X)),,$(error X is empty))

# Quiet commands
$(X)quiet_cmd_cc        = @echo '  CC     $$< => $$@';
$(X)quiet_cmd_link      = @echo '  LINK   $$@';
$(X)quiet_cmd_ar        = @echo '  AR     $$@';
$(X)quiet_cmd_mkdir     = @echo '  MKDIR  $$@';
$(X)quiet_cmd_objcopy   = @echo 'OBJCOPY  $$@';
$(X)quiet_cmd_clean     = @echo '  CLEAN';
$(X)quiet_cmd_distclean = @echo 'DISTCLEAN';

#-------------------------------------------------------------------#
# Replace the pattern .. with !! in the path names in order that    #
# no directories are out of the object directory                    #
#  $1 -- The path names                                             #
#-------------------------------------------------------------------#
$(X)tr_objdir = $(subst /./,/,$(if $($(X)objdir),$(subst ..,!!,$1),$1))

#--------------------------------------------------#
# Exclude user-specified files from source list.   #
#  $1 -- The sources list                          #
#--------------------------------------------------#
$(X)exclude = $(filter-out $($(X)EXCLUDE_FILES),$1)

#---------------------------------------------#
# Replace the specified suffixes with $(O).   #
#  $1 -- The file names                       #
#  $2 -- The suffixes                         #
#---------------------------------------------#
$(X)get_object_names  = $(call $(X)tr_objdir,$(addprefix $($(X)objdir),$(foreach i,$2,$(patsubst %.$i,%.$($(X)O),$(filter %.$i,$1)))))

#--------------------------------------------------------------------#
# Set up one static pattern rule                                     #
#  $1 -- The static pattern rule                                     #
#--------------------------------------------------------------------#
define $(X)static_pattern_rules
$1
	$(call $(X)cmd,cc)

endef

#==============================================================#
# Arugments:
#  $1 - The source directory
#  $2 - The source extension
#  $3 - The source list: equal to $(wildcard $1/*.$2)
#  $4 - The depend list
#==============================================================#
$(X)static_pattern_rules_text =$(call check_vars,$(X)__local_v)
$(X)static_pattern_rules_text +=$(if $(strip $3), \
 $(eval $(X)__local_v = $(call $(X)get_object_names,$3,$($(X)SRC_EXTS))) \
 $(call $(X)static_pattern_rules,$($(X)__local_v) $(eval $(X)__local_v := $(if $(subst ./,,$1),$1)): \
  $(call $(X)tr_objdir,$($(X)objdir)$($(X)__local_v)%.$($(X)O)) : $($(X)__local_v)%.$2 $4 | $(call $(X)tr_objdir,$($(X)objdir)$1)))
$(X)static_pattern_rules_text +=$(call clean_vars,$(X)__local_v)

#**************************************************************
#  Variables
#**************************************************************
$(X)cmd = $(if $(strip $(V1ERBOSE)),,$($(X)quiet_cmd_$1))$($(X)cmd_$1)

$(X)cmd_cc        = $(if $(COMPILE[$1]),$(COMPILE[$1]),$($(X)GCC) -I$$(dir $$<) $($(X)cflags) $($(X)cflags[$$<]) -c -o $$@ $$<)
$(X)cmd_link      = $($(X)LINK) $($(X)ldflags) $($(X)objects) $($(X)LIBS) -o $$@
$(X)cmd_mkdir     = mkdir -p $$@
$(X)cmd_ar        = rm -f $@ && $($(X)AR) rcvs $@ $($(X)objects)
$(X)cmd_objcopy   =	$($(X)OBJCOPY) -$(X)O binary $$< $@
$(X)cmd_clean     = rm -rf $(filter-out ./,$($(X)objdir)) $($(X)TARGET) $($(X)objects)
$(X)cmd_distclean = find -name '*.$($(X)O)' -o -name '*.$($(X)D)' | xargs rm -f

$(X)O := $(if $($(X)OBJ_EXT),$($(X)OBJ_EXT),o)
$(X)D := $(if $($(X)DEP_EXT),$($(X)DEP_EXT),d)

ifndef $(X)SRC_EXTS
$(X)SRC_EXTS := $(DEFAULT_SRC_EXTS)
endif
$(X)source_filters := $(foreach i,$($(X)SRC_EXTS),%.$i)

$(X)objdir := $(strip $($(X)OBJ_DIR))
$(X)objdir := $(patsubst ./%,%,$(if $($(X)objdir),$(call std_path,$($(X)objdir)/)))

## Combine compiler flags togather.
$(X)cflags  = $($(X)CFLAGS) $(foreach i,$($(X)INCS),-I$i) $($(X)DEFINES) $(EXTRA_CFLAGS)
$(X)ldflags = $($(X)LDFLAGS)

## Output file types:
##  EXE:  Application
##  AR:   static library
##  SO:   shared object
##  DLL:  dynamic link library
##  BIN:  raw binary
$(X)TARGET_TYPE := $(strip $(TARGET_TYPE))
ifeq ($(filter $($(X)TARGET_TYPE),SO DLL AR EXE BIN),)
$(error Unknown TARGET_TYPE '$($(X)TARGET_TYPE)')
endif

ifneq ($(filter DLL SO,$($(X)TARGET_TYPE)),)
$(X)cflags  += -shared
$(X)ldflags += -shared
endif
ifneq ($($(X)STRIP_UNUSED),)
$(X)cflags  += -ffunction-sections -fdata-sections
$(X)ldflags += --gc-sections
endif

$(X)cflags += -MMD -MF $$@.$($(X)D) -MT $$@

##$(X)depend_list = $(if $(INDEPENDENT_OF_MAKEFILE_LIST),,$(MAKEFILE_LIST)) $($(X)EXTERNAL_DEPENDS)

# $1 - The source directory
# $2 - The source extension
# $3 - The source list: equal to $(wildcard $1/*.$2)
construct_internal_variables =$(call check_vars,__scmt_v2)
construct_internal_variables +=$(if $(strip $3), \
 $(call nl,sources-$1.$2=$3) \
 $(eval __scmt_v2 = $(call get_object_names,$3,$(SRC_EXTS))) \
 $(call nl,objects-$1.$2=$(__scmt_v2)) \
 $(call static_pattern_rules,$(__scmt_v2) $(eval __scmt_v2 := $(if $(subst ./,,$1),$1)): \
  $(call tr_objdir,$(objdir)$(__scmt_v2)%.$O) : $(__scmt_v2)%.$2 $(depend_list) | $(call tr_objdir,$(objdir)$1)))
construct_internal_variables +=$(call clean_vars,__scmt_v2)

#-------------------------------------#
# Get the list of all source files    #
#-------------------------------------#
$(X)src_f    = $(call get_path_list,$(filter $($(X)source_filters),$($(X)SRCS)))
$(X)src_d    = $(call get_path_list,$(filter %/,$($(X)SRCS)))

$(X)sources  = $(patsubst ./%,%,$(foreach i,$($(X)SRC_EXTS),$(foreach j,$($(X)src_d),$(wildcard $j*.$i))))
$(X)src_f   := $(foreach i,$($(X)src_f),$(if $(filter $i,$($(X)sources)),,$i))
$(X)sources := $(call $(X)exclude,$($(X)sources) $($(X)src_f))

#$(info $(X)src_d = $($(X)src_d))
#$(info $(X)sources = $($(X)sources))

$(X)GCC     := $(GNU_TOOLCHAIN_PREFIX)gcc
$(X)G++     := $(GNU_TOOLCHAIN_PREFIX)g++
$(X)AR      := $(GNU_TOOLCHAIN_PREFIX)ar
$(X)NM      := $(GNU_TOOLCHAIN_PREFIX)nm
$(X)OBJCOPY := $(GNU_TOOLCHAIN_PREFIX)objcopy
$(X)OBJDUMP := $(GNU_TOOLCHAIN_PREFIX)objdump
$(X)LINK    := $(if $(strip $(filter %.cpp %.cc %.cxx,$($(X)sources))),$($(X)G++),$($(X)GCC))

ifeq ($(strip $($(X)sources)),)

$(error Empty source list! Please check both SRCS and SRC_EXTS are correctly set.)
endif

$(X)object_dirs = $(call $(X)tr_objdir,$(addprefix $($(X)objdir),$(sort $(dir $($(X)sources))))) $(dir $($(X)TARGET))

#-------------------------------------#
# The list of all object files        #
#-------------------------------------#
$(X)objects = $(call $(X)get_object_names,$($(X)sources),$($(X)SRC_EXTS))
#-------------------------------------#
# The list of all dependent files     #
#-------------------------------------#
$(X)depends = $(foreach i,$($(X)objects),$i.$($(X)D))

ALL_DEP_FILTERS += %.$($(X)O).$($(X)D)

##$(X)depend_list = $(if $(strip $(INDEPENDENT_OF_MAKEFILE_LIST)),,$(foreach i,$(ALL_DEP_FILTERS),$(info filter-out, $i, $(MAKEFILE_LIST))$(filter-out,$i,$(MAKEFILE_LIST)))) $($(X)EXTERNAL_DEPENDS)
$(X)depend_list = $(foreach i,$(ALL_DEP_FILTERS),$(filter-out $i,$(MAKEFILE_LIST))) $($(X)EXTERNAL_DEPENDS)

#----------------------------------------------------#
# Construct Rules
#----------------------------------------------------#
$(call exec, \
	$(foreach i,$(filter-out ./,$($(X)src_d)), \
 $(foreach j,$($(X)SRC_EXTS), \
  $(call $(X)static_pattern_rules_text,$i,$j,$(call $(X)exclude,$(wildcard $i*.$j)),$($(X)depend_list)))) \
$(if $(filter ./,$($(X)src_d)), \
  $(foreach j,$($(X)SRC_EXTS),$(call $(X)static_pattern_rules_text,./,$j,$(call $(X)exclude,$(wildcard *.$j)),$($(X)depend_list)))) \
$(foreach i,$($(X)src_f),$(call $(X)static_pattern_rules,$(eval __ymt_v2:=$(call $(X)get_object_names,$i,$(DEFAULT_SRC_EXTS))) \
 $(__ymt_v2): $i $(dir $(call $(X)tr_objdir,$(__ymt_v2))))))

$(call exec,$(foreach i,$(strip $($(X)object_dirs)),$(if $(call in_list,$i,$(ALL_OBJDIRS)),,$i)) : % : ; $(call $(X)cmd,mkdir))
$(eval ALL_OBJDIRS += $($(X)object_dirs))

define $(X)build_static_library
$($(X)TARGET): $($(X)TARGET_DEPENDS) $($(X)objects)
	$(call $(X)cmd,ar)

endef

define $(X)build_raw_binary
target1  = $(basename $($(X)TARGET)).elf
$(X)ldflags += -nodefaultlibs -nostdlib -nostartfiles
$($(X)TARGET): $(target1)
	$(call $(X)cmd,objcopy)
#	$(GNU_TOOLCHAIN_PREFIX)objdump -d $(target1) > $(basename $(@F)).lst
#	$(GNU_TOOLCHAIN_PREFIX)nm $(target1) | sort -k1 > $(basename $(@F)).map
endef

define $(X)build_elf
$($(X)TARGET): $($(X)TARGET_DEPENDS) $($(X)objects)
	$(call $(X)cmd,link)
endef

$(call exec, \
 $(if $(call eq,$($(X)TARGET_TYPE),LIB),$($(X)build_static_library)) \
 $(if $(call eq,$($(X)TARGET_TYPE),BIN),$($(X)build_raw_binary)) \
 $(if $(call eq,$($(X)TARGET_TYPE),EXE),$($(X)build_elf)) \
 $(if $(call eq,$($(X)TARGET_TYPE),SO),$($(X)build_elf)))

$(call exec, clean-$($(X)TARGET): ; $(call $(X)cmd,clean))
$(call exec, distclean-$($(X)TARGET): clean-$($(X)TARGET) ; $(call $(X)cmd,distclean))

sinclude $(if $(call eq,all,$(if $(MAKECMDGOALS),$(MAKECMDGOALS),$(.DEFAULT_GOAL))),$(foreach i,$($(X)objects),$i.$($(X)D)))

endif # CORE_BUILD_RULES

